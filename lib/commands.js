// Generated by CoffeeScript 1.7.1
(function() {
  var coffeeCmd, colors, dump, dumpfile, e, exec, fork, fs, mkdirp, path, _checkWatcher, _parseOptions, _ref;

  path = require('path');

  fs = require('fs');

  mkdirp = require('mkdirp');

  colors = require('colors');

  coffeeCmd = require('coffee-script/lib/coffee-script/command');

  _ref = require('child_process'), exec = _ref.exec, fork = _ref.fork;

  dumpfile = path.join(process.env.HOME, '~/.cakedog.json');

  try {
    dump = require(dumpfile);
  } catch (_error) {
    e = _error;
    dump = {};
  }

  _parseOptions = function(options) {
    var output, source;
    if (options == null) {
      options = {};
    }
    output = options.output, source = options.source;
    output || (output = process.cwd());
    source || (source = process.cwd());
    output = path.resolve(output);
    source = path.resolve(source);
    if (!fs.existsSync(source)) {
      mkdirp.sync(source);
    }
    options.source = source;
    options.output = output;
    return options;
  };

  _checkWatcher = function(pid, callback) {
    if (pid == null) {
      return callback();
    }
    return exec("ps -p " + pid + " | grep -v 'grep' | grep 'cake-dog'", function(err, result) {
      if ((err != null) || (result != null ? result.trim().length : void 0) < 1) {
        console.error(("Warn! Watcher " + pid + " was exited unexpectedly last time").yellow);
        return callback();
      } else {
        console.error("Error! Watcher is running now".red);
        return callback(new Error('WATHER_RUNNING'));
      }
    });
  };

  exports.compile = function(options) {
    var a1, a2, output, source, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    _ref1 = _parseOptions(options), output = _ref1.output, source = _ref1.source;
    _ref2 = process.argv, a1 = _ref2[0], a2 = _ref2[1];
    process.argv = [a1, a2, '-o', output, '-c', source];
    coffeeCmd.run();
    return console.log('Compile finish'.green);
  };

  exports.watch = function(options) {
    var output, pid, source, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    _ref1 = _parseOptions(options), output = _ref1.output, source = _ref1.source;
    pid = (_ref2 = dump[source]) != null ? _ref2.pid : void 0;
    return _checkWatcher(pid, function(err) {
      var child;
      if (err != null) {
        return;
      }
      process.chdir(source);
      child = fork(path.resolve(__dirname, 'fork'), ['-w', '-o', output, '-c', source]);
      dump[source] = {
        pid: child.pid,
        source: source,
        output: output
      };
      fs.writeFileSync(dumpfile, JSON.stringify(dump, null, 2));
      console.log(("Watching " + source + ", pid: " + child.pid).green);
      return process.exit();
    });
  };

  exports.unwatch = function(options) {
    if (options == null) {
      options = {};
    }
  };

  exports.resurrect = function(options) {
    if (options == null) {
      options = {};
    }
  };

}).call(this);
